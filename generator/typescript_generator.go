package generator

import (
	"fmt"
	"os"
	"strings"

	"github.com/deanrtaylor1/type-utils/config"
	"github.com/deanrtaylor1/type-utils/constants"
	"github.com/deanrtaylor1/type-utils/listener"
)

type TypeScriptSchemaGenerator struct {
	file           *os.File
	listenerConfig *listener.Config
	schema         map[string]*listener.SchemaType
	types          []string
	config.TypeUtilConfiger
}

func (t *TypeScriptSchemaGenerator) GetFile() *os.File {
	return t.file
}

func (t *TypeScriptSchemaGenerator) GetConfig() *listener.Config {
	return t.listenerConfig
}

func (t *TypeScriptSchemaGenerator) GetSchema() map[string]*listener.SchemaType {
	return t.schema
}

func (t *TypeScriptSchemaGenerator) GeneratePackageDeclaration(config *listener.Config) (string, error) {
	return fmt.Sprintf("// Generated types for %s", config.PackageName), nil
}

func (t *TypeScriptSchemaGenerator) GenerateTypeDefinition(typeName string, schemaType *listener.SchemaType) (string, error) {
	var b strings.Builder
	fmt.Fprintf(&b, "interface %s {\n", typeName)
	for fieldName, fieldType := range schemaType.Fields {
		fieldDef, err := t.GenerateFieldDefinition(fieldName, &fieldType)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "  %s\n", fieldDef)
	}
	fmt.Fprintln(&b, "}")
	t.types = append(t.types, typeName)
	return b.String(), nil
}

func (t *TypeScriptSchemaGenerator) GenerateFieldDefinition(fieldName string, fieldType *listener.FieldType) (string, error) {
	arrayStr := ""
	optionalStr := ""
	if fieldType.IsArray {
		arrayStr = "[]"
	}
	if fieldType.IsOptional {
		optionalStr = "?"
	}
	tsType := t.ConvertType(fieldType.Type)
	return fmt.Sprintf("%s%s: %s%s;", fieldName, optionalStr, tsType, arrayStr), nil
}

func (t *TypeScriptSchemaGenerator) ConvertType(fieldType string) string {
	switch fieldType {
	case constants.TypeString:
		return "string"
	case constants.TypeInt, constants.TypeInt32, constants.TypeInt64, constants.TypeFloat, constants.TypeDouble:
		return "number"
	case constants.TypeBoolean:
		return "boolean"
	case constants.TypeDate, constants.TypeTime, constants.TypeDateTime, constants.TypeTimestamp:
		return "Date"
	default:
		return getTypeForTS(fieldType)
	}
}

func getTypeForTS(str string) string {
	s := strings.Split(str, ".")
	return s[len(s)-1]
}

func (t *TypeScriptSchemaGenerator) Final() (string, error) {
	var b strings.Builder
	fmt.Fprintln(&b, "\n// Export all types")
	fmt.Fprintln(&b, "export {")
	for _, typeName := range t.types {
		fmt.Fprintf(&b, "    %s,\n", typeName)
	}
	fmt.Fprintln(&b, "}")
	fmt.Fprintln(&b, "\n// Types generated by type-utils")
	return b.String(), nil
}

func (t *TypeScriptSchemaGenerator) GetGenerateConstructors() bool {
	return false
}
