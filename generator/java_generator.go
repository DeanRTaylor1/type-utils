package generator

import (
	"fmt"
	"os"
	"strings"

	"github.com/deanrtaylor1/type-utils/config"
	"github.com/deanrtaylor1/type-utils/listener"
	"github.com/deanrtaylor1/type-utils/utils"
)

type JavaSchemaGenerator struct {
	file           *os.File
	schema         map[string]*listener.SchemaType
	listenerConfig *listener.Config
	config.TypeUtilConfiger
}

func NewJavaSchemaGenerator(file *os.File, conf config.TypeUtilConfiger, schema map[string]*listener.SchemaType) *JavaSchemaGenerator {
	return &JavaSchemaGenerator{
		file:             file,
		TypeUtilConfiger: conf,
		schema:           schema,
	}
}

func (j *JavaSchemaGenerator) GetConfig() *listener.Config {
	return j.listenerConfig
}

func (j *JavaSchemaGenerator) GetFile() *os.File {
	return j.file
}

func (j *JavaSchemaGenerator) GetSchema() map[string]*listener.SchemaType {
	return j.schema
}

func (j *JavaSchemaGenerator) GeneratePackageDeclaration(config *listener.Config) (string, error) {
	return fmt.Sprintf("package %s;\n", config.PackageName), nil
}

func (j *JavaSchemaGenerator) GenerateTypeDefinition(typeName string, schemaType *listener.SchemaType) (string, error) {
	var b strings.Builder

	// Generate interface
	fmt.Fprintf(&b, "public interface I%s {\n", typeName)
	for fieldName, fieldType := range schemaType.Fields {
		javaType := j.ConvertType(fieldType.Type)
		if fieldType.IsArray {
			javaType = "List<" + javaType + ">"
		}
		fmt.Fprintf(&b, "    %s get%s();\n", javaType, utils.CapitalizeFirstLetter(fieldName))
		fmt.Fprintf(&b, "    void set%s(%s %s);\n", utils.CapitalizeFirstLetter(fieldName), javaType, fieldName)
	}
	fmt.Fprintln(&b, "}\n")

	// Generate class
	fmt.Fprintf(&b, "public class %s implements I%s {\n", typeName, typeName)

	// Fields
	for fieldName, fieldType := range schemaType.Fields {
		javaType := j.ConvertType(fieldType.Type)
		if fieldType.IsArray {
			javaType = "List<" + javaType + ">"
		}
		fmt.Fprintf(&b, "    private %s %s;\n", javaType, fieldName)
	}
	fmt.Fprintln(&b)

	// Constructor
	if j.GetGenerateConstructors() {
		fmt.Fprintf(&b, "    public %s(", typeName)
		var params []string
		for fieldName, fieldType := range schemaType.Fields {
			javaType := j.ConvertType(fieldType.Type)
			if fieldType.IsArray {
				javaType = "List<" + javaType + ">"
			}
			params = append(params, fmt.Sprintf("%s %s", javaType, fieldName))
		}
		fmt.Fprintf(&b, strings.Join(params, ", "))
		fmt.Fprintln(&b, ") {")
		for fieldName := range schemaType.Fields {
			fmt.Fprintf(&b, "        this.%s = %s;\n", fieldName, fieldName)
		}
		fmt.Fprintln(&b, "    }\n")
	}

	// Getters and Setters
	for fieldName, fieldType := range schemaType.Fields {
		javaType := j.ConvertType(fieldType.Type)
		if fieldType.IsArray {
			javaType = "List<" + javaType + ">"
		}
		capFieldName := utils.CapitalizeFirstLetter(fieldName)

		// Getter
		fmt.Fprintf(&b, "    @Override\n")
		fmt.Fprintf(&b, "    public %s get%s() {\n", javaType, capFieldName)
		fmt.Fprintf(&b, "        return this.%s;\n", fieldName)
		fmt.Fprintf(&b, "    }\n\n")

		// Setter
		fmt.Fprintf(&b, "    @Override\n")
		fmt.Fprintf(&b, "    public void set%s(%s %s) {\n", capFieldName, javaType, fieldName)
		fmt.Fprintf(&b, "        this.%s = %s;\n", fieldName, fieldName)
		fmt.Fprintf(&b, "    }\n\n")
	}

	fmt.Fprintln(&b, "}")

	return b.String(), nil
}

func (j *JavaSchemaGenerator) GenerateFieldDefinition(fieldName string, fieldType *listener.FieldType) (string, error) {
	// This method is not directly used in Java generation, but we'll keep it for consistency
	javaType := j.ConvertType(fieldType.Type)
	if fieldType.IsArray {
		javaType = "List<" + javaType + ">"
	}
	return fmt.Sprintf("%s %s", javaType, fieldName), nil
}

func (j *JavaSchemaGenerator) ConvertType(fieldType string) string {
	switch fieldType {
	case "string":
		return "String"
	case "int":
		return "Integer"
	case "number":
		return "Double"
	case "float":
		return "Float"
	case "time":
		return "java.time.LocalDateTime"
	case "boolean":
		return "Boolean"
	default:
		return fieldType // For custom types, use the type name as is
	}
}

func (j *JavaSchemaGenerator) Final() (string, error) {
	return "\n// Types generated by type-utils", nil
}
