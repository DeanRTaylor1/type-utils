package generator

import (
	"fmt"
	"os"
	"strings"

	"github.com/deanrtaylor1/type-utils/config"
	"github.com/deanrtaylor1/type-utils/constants"
	"github.com/deanrtaylor1/type-utils/listener"
)

type JavaScriptSchemaGenerator struct {
	file           *os.File
	listenerConfig *listener.Config
	schema         map[string]*listener.SchemaType
	types          []string
	config.TypeUtilConfiger
}

func (j *JavaScriptSchemaGenerator) GetFile() *os.File {
	return j.file
}

func (j *JavaScriptSchemaGenerator) GetConfig() *listener.Config {
	return j.listenerConfig
}

func (j *JavaScriptSchemaGenerator) GetSchema() map[string]*listener.SchemaType {
	return j.schema
}

func (j *JavaScriptSchemaGenerator) GeneratePackageDeclaration(config *listener.Config) (string, error) {
	return fmt.Sprintf("// Generated types for %s", config.PackageName), nil
}

func (j *JavaScriptSchemaGenerator) GenerateTypeDefinition(typeName string, schemaType *listener.SchemaType) (string, error) {
	var b strings.Builder

	// Generate JSDoc type definition
	fmt.Fprintf(&b, "/**\n * @typedef {Object} %s\n", typeName)
	for fieldName, fieldType := range schemaType.Fields {
		fieldDef, err := j.GenerateFieldDefinition(fieldName, &fieldType)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, " * %s\n", fieldDef)
	}
	fmt.Fprintln(&b, " */")

	// Generate class definition
	fmt.Fprintf(&b, "class %s {\n", typeName)
	fmt.Fprintln(&b, "  constructor(data) {")
	for fieldName := range schemaType.Fields {
		fmt.Fprintf(&b, "    this.%s = data.%s;\n", fieldName, fieldName)
	}
	fmt.Fprintln(&b, "  }")
	fmt.Fprintln(&b, "}")

	j.types = append(j.types, typeName)
	return b.String(), nil
}

func (j *JavaScriptSchemaGenerator) GenerateFieldDefinition(fieldName string, fieldType *listener.FieldType) (string, error) {
	arrayStr := ""
	optionalStr := ""
	if fieldType.IsArray {
		arrayStr = "[]"
	}
	if fieldType.IsOptional {
		optionalStr = " [optional]"
	}
	jsType := j.ConvertType(fieldType.Type)
	return fmt.Sprintf("@property {%s%s} %s%s", jsType, arrayStr, fieldName, optionalStr), nil
}

func (j *JavaScriptSchemaGenerator) ConvertType(fieldType string) string {
	switch fieldType {
	case constants.TypeString:
		return "string"
	case constants.TypeInt, constants.TypeInt32, constants.TypeInt64, constants.TypeFloat, constants.TypeDouble:
		return "number"
	case constants.TypeBoolean:
		return "boolean"
	case constants.TypeDate, constants.TypeTime, constants.TypeDateTime, constants.TypeTimestamp:
		return "Date"
	default:
		return getTypeForJS(fieldType)
	}
}

func getTypeForJS(str string) string {
	s := strings.Split(str, ".")
	return s[len(s)-1]
}

func (j *JavaScriptSchemaGenerator) Final() (string, error) {
	var b strings.Builder

	if j.GetConfig().GetJsModuleSystem() == "es6" {
		fmt.Fprintln(&b, "\n// Export all types")
		fmt.Fprintln(&b, "export {")
		for i, typeName := range j.types {
			if i == len(j.types)-1 {
				fmt.Fprintf(&b, "    %s\n", typeName)
			} else {
				fmt.Fprintf(&b, "    %s,\n", typeName)
			}
		}
		fmt.Fprintln(&b, "}")
	} else {
		fmt.Fprintln(&b, "\n// CommonJS module exports")
		fmt.Fprintln(&b, "module.exports = {")
		for i, typeName := range j.types {
			if i == len(j.types)-1 {
				fmt.Fprintf(&b, "    %s\n", typeName)
			} else {
				fmt.Fprintf(&b, "    %s,\n", typeName)
			}
		}
		fmt.Fprintln(&b, "};")
	}

	fmt.Fprintln(&b, "\n\n\n\n// Types generated by type-utils")
	return b.String(), nil
}

func (j *JavaScriptSchemaGenerator) GetGenerateConstructors() bool {
	return true
}
