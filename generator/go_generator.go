package generator

import (
	"fmt"
	"os"
	"strings"

	"github.com/deanrtaylor1/type-utils/config"
	"github.com/deanrtaylor1/type-utils/constants"
	"github.com/deanrtaylor1/type-utils/listener"
	"github.com/deanrtaylor1/type-utils/utils"
)

type GoSchemaGenerator struct {
	file           *os.File
	listenerConfig *listener.Config
	schema         map[string]*listener.SchemaType
	config.TypeUtilConfiger
}

func (g *GoSchemaGenerator) GetFile() *os.File {
	return g.file
}

func (g *GoSchemaGenerator) GetConfig() *listener.Config {
	return g.listenerConfig
}

func (g *GoSchemaGenerator) GetSchema() map[string]*listener.SchemaType {
	return g.schema
}

func (g *GoSchemaGenerator) GeneratePackageDeclaration(config *listener.Config) (string, error) {
	return fmt.Sprintf("package %s", config.PackageName), nil
}

func (g *GoSchemaGenerator) GenerateTypeDefinition(typeName string, schemaType *listener.SchemaType) (string, error) {
	var b strings.Builder

	// Generate struct definition
	fmt.Fprintf(&b, "type %s struct {\n", typeName)
	for fieldName, fieldType := range schemaType.Fields {
		fieldDef, err := g.GenerateFieldDefinition(fieldName, &fieldType)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "\t%s\n", fieldDef)
	}
	fmt.Fprintln(&b, "}")

	// Generate New function
	fmt.Fprintf(&b, "\nfunc New%s(", typeName)

	// Function parameters
	var params []string
	for fieldName, fieldType := range schemaType.Fields {
		paramType := g.ConvertType(fieldType.Type)
		if fieldType.IsArray {
			paramType = "[]" + paramType
		}
		params = append(params, fmt.Sprintf("%s %s", fieldName, paramType))
	}
	fmt.Fprintf(&b, strings.Join(params, ", "))
	fmt.Fprintf(&b, ") *%s {\n", typeName)

	// Function body
	fmt.Fprintf(&b, "\treturn &%s{\n", typeName)
	for fieldName := range schemaType.Fields {
		fmt.Fprintf(&b, "\t\t%s: %s,\n", utils.CapitalizeFirstLetter(fieldName), fieldName)
	}
	fmt.Fprintln(&b, "\t}")
	fmt.Fprintln(&b, "}")

	return b.String(), nil
}

func (g *GoSchemaGenerator) GenerateFieldDefinition(fieldName string, fieldType *listener.FieldType) (string, error) {
	arrayStr := ""
	optionalStr := ""
	if fieldType.IsArray {
		arrayStr = "[]"
	}
	if fieldType.IsOptional {
		optionalStr = ",omitempty"
	}
	goType := g.ConvertType(fieldType.Type)
	return fmt.Sprintf("%s %s%s `json:\"%s%s\"`", utils.CapitalizeFirstLetter(fieldName), arrayStr, goType, fieldName, optionalStr), nil
}

func (g *GoSchemaGenerator) ConvertType(fieldType string) string {
	switch fieldType {
	case constants.TypeString:
		return "string"
	case constants.TypeInt, constants.TypeInt32:
		return "int32"
	case constants.TypeInt64:
		return "int64"
	case constants.TypeFloat, constants.TypeDouble:
		return "float64"
	case constants.TypeBoolean:
		return "bool"
	case constants.TypeDate, constants.TypeTime, constants.TypeDateTime, constants.TypeTimestamp:
		return "time.Time"
	default:
		return fieldType
	}
}

func (g *GoSchemaGenerator) Final() (string, error) {
	return "\n\n\n// types generated by type-utils", nil
}
